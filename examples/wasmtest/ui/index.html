<!DOCTYPE html>
<html lang="en">

  <!-- Standard head -->
  <head>

    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>WasmExample - Title ignored by the plugin</title>
    <link rel="stylesheet" href="style.css">

  </head>

  <!-- Tip: start hidden to avoid artifacts while loading -->
  <body style="visibility: hidden;" onload="new WasmExampleUI">
    
    <div id="main">
        <!-- Smiley face -->
        <img style="width:32px; height:25px;" src="music.gif" id="smiley">

        <!-- See comments in web-gain-example-ui.js -->
        <input type="text" placeholder="Test keyboard input here" id="kbd-demo" style="display: none;">

        <!-- Replaced with user agent -->
        <pre id="user-agent">Loading...</pre>

        <!-- The gain slider -->
        <input type="range" min="0" max="1.0" step="0.001" id="gain-slider">
    </div>

    <!-- Optional: allow debugging user interface using a browser -->
    <script src="stub-ui.js"></script>

    <!-- Implementation of class WasmExampleUI -->
    <script src="wasm-example-ui.js"></script>

    <!--
        Optional: workaround for input[type=range] sliders on Linux touchscreen

        Not sure this is a bug or feature of WebKitGTK. These elements do not
        react to touches on Linux but do on other platforms. It does not seem to
        be an Apices bug as touch works as expected for every other element.
    -->
    <script>

        if (/linux/i.test(window.navigator.platform)) {
            document.querySelectorAll('input[type=range]').forEach((el) => {
                el.addEventListener('touchmove', (ev) => {
                    const minVal = parseFloat(ev.target.min);
                    const maxVal = parseFloat(ev.target.max);
                    const width = ev.target.offsetWidth;
                    const x = ev.touches[0].clientX;                
                    const minX = ev.target.getBoundingClientRect().x;
                    const maxX = minX + width;
                    if ((x < minX) || (x > maxX)) return;
                    const normVal = (x - minX) / width;
                    const val = minVal + normVal * (maxVal - minVal);
                    ev.target.value = val;
                    ev.target.dispatchEvent(new CustomEvent('input'));
                });
            });
        }

    </script>

  </body>
</html>
